#!/usr/bin/env python3

import sys
import logging

import numpy as np
from ete3 import Tree, TreeNode

from treesapp.treesapp_args import TreeSAPPArgumentParser
from treesapp.refpkg import ReferencePackage
from treesapp import jplace_utils
from treesapp import rel_evo_dist
from treesapp import taxonomic_hierarchy as ts_taxonomy


class PhyloClust:
    def __init__(self):
        # Parameters
        self.arg_parser = TreeSAPPArgumentParser(description="A tool for sorting query sequences placed on a phylogeny"
                                                             " into phylogenetically-inferred clusters.")
        self.alpha = 0
        self.part_metric = "max"
        self.normalize = False
        self.jplace_file = ""

        # Objects for clustering
        self.refpkg = ReferencePackage()
        self._cluster_index = {}
        self._edges_to_cluster_index = {}
        return

    def load_args(self, args) -> None:
        # Load the arguments into class attributes
        self.refpkg.f__json = args.refpkg_path
        self.refpkg.slurp()

        self.part_metric = args.partition_metric
        self.jplace_file = args.jplace_file
        self.alpha = args.alpha

        # Determine whether to normalise the evolutionary distances or not
        if args.evo_dist == "red":
            self.normalize = True
        elif args.evo_dist == "raw":
            self.normalize = False
        else:
            logging.error("Unexpected distance normalisation method: '{}'.\n".format(args.evo_dist))
            sys.exit(3)
        return

    def get_arguments(self, sys_args: list) -> None:
        # Add the arguments to the argument parser
        self.arg_parser.add_refpkg_file_param()
        self.arg_parser.reqs.add_argument("-j", "--jplace", nargs='+',
                                          required=True,
                                          help="Path to one or more JPlace files generated by"
                                               " placement on a reference package's phylogeny.")
        self.arg_parser.pplace_args.add_argument("-d", "--evo_dist",
                                                 choices=["raw", "red"], default="red", required=False,
                                                 help="The evolutionary distance normalisation method to use."
                                                      " [ DEAULT = red ]")
        self.arg_parser.optopt.add_argument("-m", "--partition_metric",
                                            choices=["mean", "median", "max"], default="max", required=False,
                                            help="The metric to use when deciding when to cut a cluster. "
                                                 "[ DEFAULT = max ].")
        self.arg_parser.optopt.add_argument("-a", "--alpha",
                                            default=0.0, required=False,
                                            help="The evolutionary distance threshold defining the cluster boundaries."
                                                 " [ DEFAULT = auto ].")

        # Parse the arguments
        self.load_args(self.arg_parser.parse_args(sys_args))
        return

    @staticmethod
    def check_monophyly(node: TreeNode, group_name: str) -> bool:
        if group_name in [t.prefix_taxon() for t in getattr(node, "taxon").lineage()]:
            return True
        return False

    def group_rel_dists(self, tree: Tree, hierarchy: ts_taxonomy.TaxonomicHierarchy,
                        group_rank="species", norm=True) -> dict:
        """
        Determine the mean RED values between each pair of leaves of the same genus,
        thereby defining the expected range of values for a species.

        :param tree: A phylogenetic ete3 Tree instance
        :param hierarchy:
        :param group_rank:
        :param norm: Whether the returned distances are RED or raw, evolutionary distance (branch-length sums)
        :return:
        """
        rel_dists = {}
        for node in tree.traverse():
            if not hasattr(node, "taxon") or not hasattr(node, "rel_dist"):
                logging.error("Node {} is not complete with RED and taxonomy attributes.\n".format(node.name))
                sys.exit(17)

        group_index = hierarchy.accepted_ranks_depths[group_rank]

        for r_leaf in tree.get_leaves():  # type: TreeNode
            r_tax = getattr(r_leaf, "taxon")  # type: ts_taxonomy.Taxon
            if len(r_tax.lineage()) <= group_index:
                continue
            try:
                target_group = r_tax.prefix_taxon()  # type: str
            except IndexError:
                continue

            # Begin finding the query leaves related to the reference leaf
            for q_leaf in tree.get_leaves():  # type: TreeNode
                if q_leaf is r_leaf:
                    continue
                q_lineage = getattr(q_leaf, "taxon").lineage()
                if len(q_lineage) <= group_index:
                    continue
                # Ensure the query leaf belongs to the same taxonomic group
                if target_group not in [t.prefix_taxon() for t in q_lineage]:
                    continue

                # Calculate the RED distance between the two monophyletic nodes
                ca = r_leaf.get_common_ancestor(q_leaf)
                if self.check_monophyly(ca, target_group):
                    if norm:
                        try:
                            rel_dists[target_group].add(1-ca.rel_dist)
                        except KeyError:
                            rel_dists[target_group] = {1-ca.rel_dist}
                    else:
                        try:
                            rel_dists[target_group].add(r_leaf.get_distance(q_leaf))
                        except KeyError:
                            rel_dists[target_group] = {r_leaf.get_distance(q_leaf)}

        return rel_dists

    def calculate_distance_threshold(self, taxa_tree: Tree, taxonomy: ts_taxonomy.TaxonomicHierarchy) -> None:
        # Find the 95% confidence interval for RED values between leaves of the same genus
        grouped_rel_dists = self.group_rel_dists(taxa_tree, taxonomy, group_rank="species", norm=False)
        dists = []
        for group_dists in grouped_rel_dists.values():
            dists += group_dists
        self.alpha = np.percentile(dists, 95)
        return

    def partition_nodes(self, tree: Tree) -> dict:
        node_partitions = {}
        i = 1
        for node in tree.traverse(strategy="postorder"):  # type: TreeNode
            if node.is_leaf():
                continue
            u_l, u_r = node.get_children()  # type: TreeNode
            if u_l.dist + node.get_distance(u_l) + u_r.dist + node.get_distance(u_r) > self.alpha:
                if u_l.dist + node.get_distance(u_l) <= u_r.dist + node.get_distance(u_r):
                    node_partitions[i] = u_r
                    node.remove_child(u_r)
                    node.dist = u_l.dist + node.get_distance(u_l)
                else:
                    node_partitions[i] = u_l
                    node.remove_child(u_l)
                    node.dist = u_r.dist + node.get_distance(u_r)
                i += 1
            else:
                node.dist = max(u_l.dist + node.get_distance(u_l), u_r.dist + node.get_distance(u_r))

        # Capture the last leaf node, which should be the only one remaining in the tree
        if tree:
            node_partitions[i] = tree

        return node_partitions

    def define_tree_clusters(self, tree: Tree) -> dict:
        cluster_map = self.partition_nodes(tree)

        # TODO: Find the edges belonging to each cluster

        # TODO: Invert the dictionary to create the _edges_to_cluster_index

        return cluster_map


def cluster_phylogeny(sys_args: list) -> None:
    p_clust = PhyloClust()
    p_clust.get_arguments(sys_args)

    # Load the JPlace file
    jplace_dat = jplace_utils.jplace_parser(p_clust.jplace_file)

    # Calculate RED distances for each node
    p_clust.refpkg.tree = jplace_dat.tree
    taxa_tree = p_clust.refpkg.taxonomically_label_tree()
    red_tree = rel_evo_dist.RedTree()
    red_tree.decorate_rel_dist(taxa_tree)

    if not p_clust.alpha:
        p_clust.calculate_distance_threshold(taxa_tree, p_clust.refpkg.taxa_trie)

    # TODO: Perform maximum, mean, or median distance min-cut partitioning
    cluster_map = p_clust.define_tree_clusters(taxa_tree)

    # TODO: Map the PQueries (max_lwr or aelw?) to clusters

    # TODO: Decide what to do with the PQueries with pendant lengths greater than the cluster RED radius

    # TODO: Centroids?
    return


if __name__ == "__main__":
    cluster_phylogeny(sys.argv[1:])
