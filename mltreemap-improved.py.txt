#!/sw/bin/python
##############################
##
## MLTreeMap TSN v. 0.0
##
## To Do List
##        BLAST
##            Auto detect AA vs Nt
##        GeneWise
##            Extracts marker genes
##            1000 bp flanking
##        hmmalign
##            Align marker genes vs reference
##        Gblocks
##            Remove minor gaps
##        RAxML
##        
##        How to deal with AA vs DNA vs rRNA
##        Visualization
##
##############################

try:
    import argparse
    import sys
    from os import path
    import shutil
    import re
    import glob
    import subprocess
    import time
except:
    print """ Could not load some user defined  module functions"""
    print """ """
    print traceback.print_exc(10)
    sys.exit(3)


def os_type():
    x = sys.platform
    if x:

        hits = re.search(r'darwin', x, re.I)
        if hits :
          return 'mac'
     
        hits = re.search(r'win', x, re.I)
        if hits :
          return 'win'

        hits = re.search(r'linux', x, re.I)
        if hits:
          return 'linux'
#
# Copy Perl's ability to autovivify
#
def pathDelim():
     ostype = os_type()
     if ostype == 'win':
         return "\\"
 
     if ostype in ['linux', 'mac']:
         return "/"

PATHDELIM =  str(pathDelim())

class Autovivify(dict):
    def __getitem__(self, item):
        try:
            return dict.__getitem__(self, item)
        except KeyError:
            value = self[item] = type(self)()
            return value


#class BookKeeping:
    #we will implement a singleton class for bookkeeping

     

def getParser(): 

    #
    # Collect options from user
    #

    parser = argparse.ArgumentParser(description='TK Takes a sequence(s) and, using a Maximum Likelihood algorithm, attempts to place it in an appropriate reference tree.')
    parser.add_argument('-i', '--input', required=True, help='your sequence input file')
    parser.add_argument('-b', '--bootstraps', default=0, type=int, help='the number of Bootstrap replicates')
    parser.add_argument('-c', '--cluster', default=0, choices=[0,'s'], help='use a computer cluster? (0 = no cluster; s = sun grid)')
    parser.add_argument('-f', '--phylogeny', default='v', choices=['v','p'], help='RAxML algorithm (v = Maximum Likelihood; p = Maximum Parsimony)')
    parser.add_argument('-g', '--gblocks', default=50, type=int, help='minimal sequence length after Gblocks')
    parser.add_argument('-l', '--filelength', default=2000, type=int, help='long input files will be splint into files containing L sequences each')
    parser.add_argument('-m', '--memory', default=0, type=int, help='minimum memory on a sungrid_cluster in GB')
    parser.add_argument('-o', '--output', default='output/', help='output directory')
    parser.add_argument('-s', '--bitscore', default=60, type=int, help='minimum bitscore for the blast hits')
    parser.add_argument('-t', '--reftree', default='p', choices=['p','g','i'], help='phylogenetic reference tree (p = MLTreeMap reference tree; g = GEBA reference tree; i = fungi tree)')
    return parser

def checkParserArguments(parser):

    #
    # Ensure files contain more than 0 sequences
    #

    args = parser.parse_args()
    if args.filelength <= 0:
        sys.exit('Input files require a positive number of sequences!')
    
    #
    # Set the reference data file prefix and the reference tree name
    #
    
    if args.reftree == 'g':
        args.reference_data_prefix = 'geba_'
        args.reference_tree = 'geba.tree'
    elif args.reftree == 'i':
        args.reference_data_prefix = 'fungi_'
        args.reference_tree = 'fungitr_tree.txt'
    else:
        args.reference_data_prefix = ''
        args.reference_tree = 'MLTreeMap_reference.tree'

    return args

#
# Prompt the user how to deal with the output directory if it already exists
#

def removePreviousOutput(args):
    while os.path.isdir(args.output):
        print('WARNING: Your output directory "' + args.output + '" already exists!')
        print('Overwrite [1], quit [2], or change directory [3]?')
        answer = raw_input()
        answer = int(answer)
        while not answer == 1 and not answer == 2 and not answer == 3:
            answer = raw_input('Invalid input. Please choose 1, 2, or 3.\n')
            answer = int(answer)
        if answer == 1:
            print('Do you really want to overwrite the old output directory?')
            print('All data in it will be lost!')
            answer2 = raw_input('Yes [y] or no [n]?\n')
            while not answer2 == 'y' and not answer2 == 'n':
                answer2 = raw_input('Invalid input. Please choose y or n.\n')
            if answer2 == 'y':
                shutil.rmtree(args.output)
            else:
                sys.exit('Exit MLTreeMap\n')
        elif answer == 2:
            sys.exit('Exit MLTreeMap\n')
        else:
            args.output = raw_input('Please enter the path to the new directory.\n')
    
    #
    # Create the output directories
    #
    
    if (not re.search('/$', args.output)):
        args.output = args.output + '/'
    os.makedirs(args.output)
    os.mkdir(args.output + 'various_outputs/')
    os.mkdir(args.output + 'final_RAxML_outputs/')
    os.mkdir(args.output + 'final_outputs/')

    return args

def createCogList(args):
    
    #
    # Create list of MLTreeMap COGs
    #
    
    cog_list = Autovivify()
    text_of_analysis_type = Autovivify()
    alignment_set = args.reftree
    kind_of_cog = ''
    
    #
    # For each line in the COG list file...
    #
    
    cogInputList = open('data/tree_data/cog_list.txt', 'r')
     
    cogList = [ x.strip() for x in cogInputList.readlines() ] 
    for cogInput in cogList:
        
        #
        # Get the kind of COG if cogInput is a header line
        #
        
        if (re.match(r'\A#(.*)', cogInput)):
            kind_of_cog = re.match(r'\A#(.*)', cogInput).group(1)
            continue
        
        #
        # Add data to COG list based on the kind of COG it is
        #
        
        if (kind_of_cog == 'phylogenetic_cogs'):
            cog_list[kind_of_cog][cogInput] = alignment_set
            cog_list['all_cogs'][cogInput] = alignment_set
            text_inset = ''
            if (alignment_set == 'g'):
                text_inset = ' based on the GEBA reference'
            if (alignment_set == 'i'):
                text_inset = ' focusing only on fungi'
            text_of_analysis_type[alignment_set] = 'Phylogenetic analysis' + text_inset + ':'
        elif (kind_of_cog == 'phylogenetic_rRNA_cogs'):
            cog, denominator, text = cogInput.split('\t')
            cog_list[kind_of_cog][cog] = denominator
            cog_list['all_cogs'][cog] = denominator
            text_of_analysis_type[denominator] = 'Phylogenetic analysis, ' + text + ':'
        elif (kind_of_cog == 'functional_cogs'):
            cog, denominator, text = cogInput.split('\t')
            cog_list[kind_of_cog][cog] = denominator
            cog_list['all_cogs'][cog] = denominator
            text_of_analysis_type[denominator] = 'Functional analysis, ' + text + ':'
            
    #
    # Close the COG list file
    #
    
    cogInputList.close()

    return (cog_list, text_of_analysis_type)

def splitFastaInput(args):

    #
    # Confirm input file is a fasta file
    #

    input = open(args.input, 'r')
    
    if (not input.read(1) == '>'):
        sys.exit('ERROR: Your file does not appear to be a proper FASTA file!\n')
    
    #
    # Unread the '>' to prevent problems later
    #
    
    input.seek(-1,1)
    
    #
    # Determine the output file names
    # Open the output files
    #
    
    if (re.match(r'\A.*\/(.*)', args.input)):
        inputFileName = re.match(r'\A.*\/(.*)', args.input).group(1)
    else:
        inputFileName = args.input
    
    outputSplit = open(args.output + PATHDELIM + 'various_outputs' + PATHDELIM + inputFileName + '_0.txt', 'w')
    outputFormatted = open(args.output + PATHDELIM +  'various_outputs' + PATHDELIM + inputFileName + '_formatted.txt', 'w')
    countFiles = 0
    countSequences = 0
    
    #
    # Iterate through the input file...
    #
    
    countTotal = 0
    countNucleotides = 0
    countXN = 0
    countUndef = 0
    splitFiles = []
    
    for line in input:
    
        if (re.search('\A>', line)):
        
            countSequences += 1
        
            #
            # Replace all non a-z, A-Z, 0-9, or . characters with a _
            # Then replace the initial _ with a >
            #
        
            line = re.sub(r'[^a-zA-Z0-9.\r\n]', '_', line)
            line = re.sub(r'\A_', '>', line)
            
            #
            # RAxML can only work with file names having length <= 125
            # Check that the sequence name length is <= 100
            # If sequence name length is > 100, limit the file name length to 100
            #
            
            if (line.__len__() > 100):
                line = line[0:100]
        
            #
            # Split the file if countSequences > the number of sequences per file specified by the user
            #
            
            if (countSequences >= args.filelength):
               countSequences = 0
               splitFiles.append(args.output + PATHDELIM + 'various_outputs' + PATHDELIM + inputFileName + '_%d.txt' %(countFiles))
               countFiles += 1
               outputSplit.close()
               outputSplit = open(args.output + PATHDELIM +  'various_outputs' + PATHDELIM + inputFileName + '_%d.txt' %(countFiles), 'w')
        else:
        
            #
            # Remove all non-characters from the sequence
            #
            
            re.sub(r'[^a-zA-Z]','', line)
            
            #
            # Count the number of {atcg} and {xn} in all the sequences
            #
    
            characters = []
            characters = list(line)
            
            for character in characters:
                countTotal += 1
                if (re.match(r'[acgtACGT]', character)):
                    countNucleotides += 1
                elif (re.match(r'[xnXN]', character)):
                    countXN += 1
                else:
                    countUndef += 1
        
        #
        # Write the lines to the appropriate files
        #
        
        outputSplit.write(line)
        outputFormatted.write(line)
    
    #
    # Close the files
    #
    
    input.close()
    outputSplit.close()
    outputFormatted.close()
        
    #
    # If splitFiles is empty, add the only file to splitFiles
    #
    
    if not splitFiles:
        splitFiles.append(args.output + 'various_outputs/' + inputFileName + '_%d.txt' %(countFiles))
    
    #
    # Exit the program if character count is 0
    #
    
    if (countTotal == 0):
        sys.exit('ERROR: Your input file appears to be corrupted. No sequences were found!\n')
    
    #
    # Exit the program if all sequences are composed only of X or N
    #
    
    elif (countXN == countTotal):
        sys.exit('ERROR: Your sequence(s) contain only X or N!\n')
    
    #
    # Exit the program if less than half of the characters are nucleotides
    # The 1.0 is to cast it as a float
    #
    
    elif (float(countNucleotides / (countTotal * 1.0)) < 0.5):
        sys.exit('ERROR: Your sequence(s) most likely contain no DNA!\n')

    return splitFiles

def createBlastDBList(args):

    #
    # Create list of databases for each blastx and blastn
    #

    blastxDB = []
    blastnDB = []
    
    for file in glob.glob('data/' + args.reference_data_prefix + 'alignment_data/*.fa'):
        file.rstrip('\r\n')
        if (not re.match(r'\Adata/' + args.reference_data_prefix + 'alignment_data/\._', file)):
            if (re.match(r'.*rRNA\.fa\Z', file)):
                blastnDB.append(file)
            elif (re.match(r'.*\.fa\Z', file) and not re.match(r'rRNA', file)):
                blastxDB.append(file)

    return (blastxDB, blastnDB)

def runBlast(args, splitFiles, blastxDB, blastnDB):
    
    #
    # For each file containing a maximum of the specified number of sequences...
    #

    for splitFile in splitFiles:
        
        #
        # Ensure splitFile is a .txt file; save file name if so, die otherwise
        #
        
        blastInputFileName = ''
        
        if (not re.match(r'\A.+/(.+)\.txt\Z', splitFile)):
            sys.exit('ERROR: Something is wrong with the directory of the BLAST input file!\n')
        else:
            blastInputFileName = re.match(r'\A.+/(.+)\.txt\Z', splitFile).group(1)
    
        #
        # BLAST splitFile against each blastx DB
        #

        command = 'sub_binaries/blastall -p blastx -i ' + splitFile + ' -M BLOSUM62 -d "'
        for db in blastxDB:
             command += db + ' '
        command += '" -e 0.01 -v 20000 -b 20000 -z 1000000 -m 8 '
        command += '> ' + args.output + 'various_outputs/' + blastInputFileName + '.BLAST_results_raw.txt'
        os.system(command)
        
        #
        # BLAST splitFile against each blastn DB
        #
        
        command = 'sub_binaries/blastall -p blastn -i ' + splitFile + ' -M BLOSUM62 -d "'
        for db in blastnDB:
            command += db + ' '
        command += '" -e 0.01 -v 20000 -b 20000 -z 1000000 -m 8 '
        command += '> ' + args.output + 'various_outputs/' + blastInputFileName + '.rRNA_BLAST_results_raw.txt'
        os.system(command)
        
        #
        # Remove the BLAST input file
        #
        
        if path.exists(splitFile):
           shutil.rmtree(splitFile)
        
    #
    # Remove empty BLAST result raw files; store non-empty files in a list
    #
    
def readBlastResults(output):
    rawBlastResultFiles = []
    
    for file in glob.glob(output + '/various_outputs/*BLAST_results_raw.txt'):
        file.rstrip('\r\n')
        if path.getsize(file) <= 0:
            shutil.rmtree(file)
        else:
            rawBlastResultFiles.append(file)
    
    return rawBlastResultFiles

def parseBlastResults(args, rawBlastResultFiles, cog_list):

    #
    # Read all BLAST results
    #

    purifiedBlastHits = Autovivify()
    
    for file in rawBlastResultFiles:
        
        #
        # Open the file
        #
        try:     
           blastResults = open(file, 'r')
        except IOError:
           print "ERROR: Cannot open BLAST outputfile " + file
           continue

        contigs = Autovivify()
        identifier = 0
        #
        # Iterate through each BLAST hit
        #
        for line in blastResults:
            
            line = line.strip()
            #
            # Clear the variables referencing the contig, COG, query start, query end, reference start, reference end, and bitscore
            #
            
            #
            # Interpret the BLAST hit, and assign the details accordingly
            #
            
            tempContig, tempDetailedCOG, _, _, _, _, tempQStart, tempQEnd, tempRStart, tempREnd, _, tempBitScore = line.split('\t')
            
            tempREnd = int(tempREnd)
            tempRStart = int(tempRStart)
            tempQEnd = int(tempQEnd)
            tempQStart = int(tempQStart)
            #
            # Skip to next BLAST hit if bit score is less than user-defined minimum
            #
            
            if tempBitScore < args.bitscore:
                continue
            
            #
            # Determine the direction of the hit relative to the reference
            #
            direction = 'forward'
            if tempREnd < tempRStart:
                temp = tempRStart
                tempRStart = tempREnd
                tempREnd = temp
                direction = 'reverse'
            
            if tempQEnd < tempQStart:
                temp = tempQStart
                tempQStart = tempQEnd
                tempQEnd = temp
                if (direction == '-'):
                    sys.exit('ERROR: Parsing error with the BLAST results. Please notify the authors about ' + tempContig + ' at ' + tempDetailedCOG + 'q('+tempQEnd+'..'+tempQStart+'),r('+tempREnd+'..'+tempRStart+')')
                direction = 'forward'
            
            #
            # Trim COG name to last 7 characters of detailed COG name
            # TK - This will be important to note in the user's manual, especially if we enable people to add their own COGs later
            #
            
            tempCOG = ''
            
            if re.match(r'.*(.{7})\Z', tempDetailedCOG):
                tempCOG = re.match(r'.*(.{7})\Z', tempDetailedCOG).group()
            else:
                sys.exit('ERROR: Could not detect the COG of sequence ' + tempDetailedCOG)
            
            #
            # Save contig details to the list
            #
            
            contigs[tempContig][identifier]['bscore'] = tempBitScore
            contigs[tempContig][identifier]['cog'] = tempCOG
            contigs[tempContig][identifier]['seq_start'] = tempQStart
            contigs[tempContig][identifier]['seq_end'] = tempQEnd
            contigs[tempContig][identifier]['direction'] = direction
            contigs[tempContig][identifier]['valid'] = 1
            identifier += 1
        #
        # Close the file
        #
        blastResults.close()
        
        #
        # Purify the BLAST hits
        #
        
        #
        # For each contig sorted by their stringwise comparison...
        #
        for contig in contigs.keys():
            identifier = 0
            #
            # For each blast result for that contig...
            #
            sorted_matches = sorted(contigs[contig].values(), key=lambda x:x['seq_start'])
            L = len(sorted_matches)

            print contig + "  " + str(L)
            for i in range(0, L):
               base_length  = sorted_matches[i]['seq_end'] - sorted_matches[i]['seq_start']
               for j in range(i + 1, L):
                  if sorted_matches[i]['seq_end'] < sorted_matches[j]['seq_start']: 
   #                  print '--- '  + str(sorted_matches[i]['seq_end']) + '   ' + str(sorted_matches[j]['seq_start']) 
                     break 
                  check_length  = sorted_matches[j]['seq_end'] - sorted_matches[j]['seq_start']
                  overlap = min(sorted_matches[i]['seq_end'], sorted_matches[j]['seq_end']) -\
                            sorted_matches[i]['seq_start']
                  base_bitscore = sorted_matches[i]['bscore']
                  check_bitscore = sorted_matches[j]['bscore']

                  if (not overlap == 0):
                        if (overlap / base_length) > 0.5 and base_bitscore < check_bitscore:
                            sorted_matches[i]['valid'] = 0
                        elif (overlap / check_length) > 0.5 and check_bitscore < base_bitscore:
                            sorted_matches[j]['valid'] = 0
                        elif sorted_matches[i]['seq_start'] == sorted_matches[j]['seq_start'] and\
                             sorted_matches[i]['seq_end'] == sorted_matches[j]['seq_end']:  
                            # If both are the same, keep only the one with the smaller identifier
                            sorted_matches[i]['valid'] = 0

               if sorted_matches[i]['valid'] == 1:
                    purifiedBlastHits[contig][identifier]['bscore'] = sorted_matches[i]['bscore']
                    purifiedBlastHits[contig][identifier]['cog'] = sorted_matches[i]['cog']
                    purifiedBlastHits[contig][identifier]['start'] =sorted_matches[i]['seq_start']
                    purifiedBlastHits[contig][identifier]['end'] = sorted_matches[i]['seq_end']
                    purifiedBlastHits[contig][identifier]['direction'] = sorted_matches[i]['direction']
                    purifiedBlastHits[contig][identifier]['is_already_placed'] = 0
                    identifier += 1
    
    
    #
    # Print the BLAST results for each contig
    #

    for contig in purifiedBlastHits:
        outfile = args.output + PATHDELIM + 'various_outputs' + PATHDELIM  + contig + '_blast_result_purified.txt'
        out = open(outfile, 'w')
        for identifier in purifiedBlastHits[contig]:
           out.write(contig + '\t' + str(purifiedBlastHits[contig][identifier]['start']) + '\t' + str(purifiedBlastHits[contig][identifier]['end']) + '\t' + purifiedBlastHits[contig][identifier]['direction'] + '\t' + purifiedBlastHits[contig][identifier]['cog'] + '\t' + str( purifiedBlastHits[contig][identifier]['bscore']) + '\n')
        out.close()

def main(argv):
    parser = getParser()
    args = checkParserArguments(parser)

    #removePreviousOutput(args):
    
    #this creates the list of the marker COGs 
    (cogList, textOfAnalysisType) = createCogList(args)

    #splits the input files to smaller files for blasting
    splitFiles = splitFastaInput(args)

    # get the appropriate type of blast DBS
    (blastxDB, blastnDB) = createBlastDBList(args)

    print('Run BLAST')
   # runBlast(args, splitFiles, blastxDB, blastnDB)

    blastResults =  readBlastResults(args.output)

    print blastResults
    print 'types of cogs'
    print cogList.keys()

    print 'all_cogs ' + str(len(cogList['all_cogs'] ))
    print 'functional_cogs ' + str(len(cogList['functional_cogs'] ))
    print 'functional_cogs ', cogList['functional_cogs'] 

    print 'phylogenetic_rRNA_cogs ' + str( len(cogList['phylogenetic_rRNA_cogs']))
    print 'phylogenetic_rRNA_cogs ',cogList['phylogenetic_rRNA_cogs']

    parseBlastResults(args, blastResults, cogList)

if __name__ == "__main__":
   main(sys.argv[1:])

